# LC-0234. Palindrome Linked List

Given the `head` of a singly linked list, return `true` if it is a palindrome.

**Example 1:**
![](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)

```
Input: head = [1,2,2,1]
Output: true
```

**Example 2:**
![](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)

```javascript
Input: head = [1, 2];
Output: false;
```

**Constraints:**

-   The number of nodes in the list is in the range `[1,10^5]`.
-   `0 <= Node.val <= 9`



**Follow up:** Could you do it in O(n) time and O(1) space?

## Solution

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var isPalindrome = function (head) {
    if (!head.next) return true;

    let dummy = new ListNode(-1, head);
    let cp = findCenter(dummy);
    let p2 = reverseList(cp.next);
    cp.next = null;

    // 开始比较
    let p1 = dummy.next;
    while (p2) {
        // 奇数个结点时，右边少一个结点，比到右边最后一个结点即可
        if (p1.val !== p2.val) return false;
        p1 = p1.next;
        p2 = p2.next;
    }
    return true;
};
const findCenter = (head) => {
    // head 必须是 dummy head
    let slow = head,
        fast = head;
    while (true) {
        if (!fast) break; // 结点数为奇数时，慢指针到达指定位置
        fast = fast.next;
        if (!fast) break; // 结点数为偶数时，慢指针到达指定位置
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
};
const reverseList = (head) => {
    // head 不能是 dummy head
    let pre = head,
        cur = pre.next;
    pre.next = null;
    while (cur) {
        let temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
};
```
