# LC-0148. Sort List

Given the `head` of a linked list, return \*the list after sorting it in **ascending order\***.

**Example 1:**
![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```
Input: head = [4,2,1,3]
Output: [1,2,3,4]
```

**Example 2:**
![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```
Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

-   The number of nodes in the list is in the range `[0, 5 * 10^4]`.
-   `-10^5 <= Node.val <= 10^5`

**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)` memory (i.e. constant space)?

## Solution

### 归并排序

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var sortList = function (head) {
    if (!head) return head;
    let count = 0,
        p = head;
    while (p) {
        count++;
        p = p.next;
    }

    const dummyHead = new ListNode(-1, head);
    for (let subLen = 1; subLen < count; subLen <<= 1) {
        let pre = dummyHead,
            cur = dummyHead.next;
        while (cur) {
            let head1 = cur;
            for (let i = 1; i < subLen && cur.next; i++) cur = cur.next;
            let head2 = cur.next;
            cur.next = null;

            cur = head2;
            for (let i = 1; i < subLen && cur && cur.next; i++) cur = cur.next;
            let next = null;
            if (cur) {
                next = cur.next;
                cur.next = null;
            }

            const merged = merge(head1, head2);
            pre.next = merged;
            while (pre.next) pre = pre.next; // 走到排完序链表的最后一个元素
            cur = next;
        }
    }
    return dummyHead.next;
};
const merge = (head1, head2) => {
    const dummyHead = new ListNode(-1, null);
    let p = dummyHead,
        p1 = head1,
        p2 = head2;
    while (p1 && p2) {
        if (p1.val <= p2.val) {
            p.next = p1;
            p1 = p1.next;
        } else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next;
    }
    if (p1) p.next = p1;
    if (p2) p.next = p2;
    return dummyHead.next;
};
```
