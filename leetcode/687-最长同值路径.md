# LC-0687. Longest Univalue Path

Given the `root` of a binary tree, return _the length of the longest path, where each node in the path has the same value_. This path may or may not pass through the root.

**The length of the path** between two nodes is represented by the number of edges between them.

**Example 1:**
![](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)

```
Input: root = [5,4,5,1,1,null,5]
Output: 2
Explanation: The shown image shows that the longest path of the same value (i.e. 5).
```

**Example 2:**
![](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg)

```
Input: root = [1,4,5,4,4,null,5]
Output: 2
Explanation: The shown image shows that the longest path of the same value (i.e. 4).
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 10^4]`.
-   `-1000 <= Node.val <= 1000`
-   The depth of the tree will not exceed `1000`.

Note: similar to `LC-0543. Diameter of Binary Tree`.

## Solution

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var longestUnivaluePath = function (root) {
    const dfs = (node) => {
        if (!node.left && !node.right) return 0;
        let leftSize = node.left === null ? 0 : dfs(node.left) + 1;
        // 和中间结点值相同时设置长度为0
        if (leftSize && node.left.val !== node.val) leftSize = 0;
        let rightSize = node.right === null ? 0 : dfs(node.right) + 1;
        if (rightSize && node.right.val !== node.val) rightSize = 0;
        ans = Math.max(ans, leftSize + rightSize);
        return Math.max(leftSize, rightSize);
    };

    let ans = 0;
    if (!root) return 0;
    dfs(root);
    return ans;
};
```
