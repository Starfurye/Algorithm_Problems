# BM73 最长回文子串

## Solution

### 动态规划

```javascript
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 *
 * @param A string字符串
 * @return int整型
 */
function getLongestPalindrome(A) {
    // write code here
    if (A.length === 1) return 1;
    let dp = new Array(A.length)
        .fill(false)
        .map(() => new Array(A.length).fill(false));
    for (let i = 0; i < A.length; i++) dp[i][i] = true;
    let ans = 1;

    for (let j = 1; j < A.length; j++) {
        for (let i = 0; i < j; i++) {
            if (A.charAt(i) === A.charAt(j)) {
                dp[i][j] = j - i <= 2 ? true : dp[i + 1][j - 1];
                if (dp[i][j]) ans = Math.max(ans, j - i + 1);
            } else dp[i][j] = false;
        }
    }
    return ans;
}
module.exports = {
    getLongestPalindrome: getLongestPalindrome,
};
```

#### 空间优化

```javascript

```

#### 如果要输出该子串

```javascript
function getLongestPalindrome(A) {
    // write code here
    if (A.length === 1) return 1;
    let dp = new Array(A.length)
        .fill(false)
        .map(() => new Array(A.length).fill(false));
    for (let i = 0; i < A.length; i++) dp[i][i] = true;
    let ans = 1;
    let begin = 0; // 为了输出子串

    for (let j = 1; j < A.length; j++) {
        for (let i = 0; i < j; i++) {
            if (A.charAt(i) === A.charAt(j)) {
                dp[i][j] = j - i <= 2 ? true : dp[i + 1][j - 1];
                if (dp[i][j] && ans < j - i + 1) {
                    ans = j - i + 1;
                    begin = i; // 记录起始位置
                }
            } else dp[i][j] = false;
        }
    }
    return A.substring(begin, begin + ans);
}
```
